
# This file was *autogenerated* from the file Ring-LWE.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8); _sage_const_40961 = Integer(40961); _sage_const_2p0 = RealNumber('2.0'); _sage_const_4p0 = RealNumber('4.0'); _sage_const_3p0 = RealNumber('3.0'); _sage_const_1024 = Integer(1024); _sage_const_16 = Integer(16)
import random
import time

def generate_matrix(dimension, modulus):
    array = []

    for i in range(_sage_const_0 , dimension):
        f = _sage_const_0 
        for j in range(_sage_const_0 , dimension):
            f += randrange(_sage_const_0 , int(modulus / _sage_const_8 )) * x**j

        array.append(f)

    return Matrix(array)


def generate_distribution(size):
    P = getenrate_probablity(_sage_const_1 , int(floor(sqrt(size))))
       
    print("Probability array: " + str(P))
    
    dist = GeneralDiscreteDistribution(P)
    
    return dist
    
    
def get_noise(dimension, modulus, dist):
    array = []

    for i in range(_sage_const_0 , dimension):
        nested = []
        degree = dist.get_random_element()
        
        for j in range(_sage_const_0 , dimension):
            if dimension - j - _sage_const_1   == degree:
                nested.append(dist.get_random_element() * x**degree)  
            else:
                nested.append(_sage_const_0 )
                
        array.append(nested)
        
    return Matrix(array)


def reconcile(poly, dimension, modulus):
    array = remove_values_from_list(poly.list(), _sage_const_0 )
    result = ""
    
    for coefficient in array:
        coefficient = int(coefficient)
        
        if (coefficient) >= (modulus / _sage_const_4p0 ) and (coefficient) <= (_sage_const_3p0  * modulus / _sage_const_4p0 ):
            result += "1"
        else:
            result += "0"  
        
        # print(str(coefficient) + "\t" + str(797 / 4.0) + "\t" + str(3.0*797 / 4) +  "\t" + str(int(1.0 * coefficient) >= (modulus / 4.0))) + "\t" + str(int((1.0 * coefficient) <= (3.0 * modulus / 4.0)))
        
    return str(result)


def reconcile2(poly, dimension, modulus, signal="null"):
    array = remove_values_from_list(poly.list(), _sage_const_0 )
    result = ""
    
    index = _sage_const_0 
    
    if signal != "null":
        temp = signal
        # print("signal: " + str(signal))
    else:
        temp = generate_signal(poly, dimension, modulus)
        

    value1 = ((modulus / _sage_const_2p0  - modulus / _sage_const_4p0 ) / _sage_const_2p0 ) + (modulus / _sage_const_4p0 )
    value2 = ((modulus - _sage_const_3p0  * modulus / _sage_const_4p0 ) / _sage_const_2p0 ) + (_sage_const_3p0  * modulus / _sage_const_4p0 )
    value3 = ((modulus / _sage_const_4p0  - _sage_const_0 ) / _sage_const_2p0 )
    value4 = ((_sage_const_3p0  * modulus / _sage_const_4p0  - modulus / _sage_const_2p0 ) / _sage_const_2p0 ) + (modulus / _sage_const_2p0 )
    
    # print(str(value1) + "\t" + str(value2) + "\t" + str(value3) + "\t" + str(value4))
    
    for coefficient in array:
        coefficient = int(coefficient)
        
        if temp[index] == "1":
            if (coefficient) >= value1 and (coefficient) <= value2:
                result += "1"
            else:
                result += "0"
        else:
            if (coefficient) >= value3 and (coefficient) <= value4:
                result += "1"
            else:
                result += "0"

        index = index + _sage_const_1 
    
    return str(result)


def generate_signal(poly, dimension, modulus):
    array = remove_values_from_list(poly.list(), _sage_const_0 )
    result = ""
    
    for coefficient in array:
        coefficient = int(coefficient)
        
        if (coefficient) <= (modulus / _sage_const_4p0 ) or ((coefficient) <= (_sage_const_3p0  * modulus / _sage_const_4p0 ) and (coefficient) >= (modulus / _sage_const_2p0 )):
            result += "1"
        else:
            result += "0"  
  
    return str(result)
    

def remove_values_from_list(the_list, val):
   return [value for value in the_list if value != val]


def getenrate_probablity(total, count):
    sub_sum = total
    random_numbers = []

    for i in range(_sage_const_0 , count - _sage_const_2 ):
        random_numbers.append(random.uniform(_sage_const_0 , sub_sum))
        sub_sum -= random_numbers[i]

    random_numbers.append(sub_sum)
   
    return random_numbers



        

start_time = time.time()
 
# constants:
#   dimension = 64
#   modulus = 797
dimension = _sage_const_16 
modulus = _sage_const_40961 
use = "FLINT"

print("Implementation: " + use);
print("Dimension: " + str(dimension));
print("Modulus: " + str(modulus));
print("Ring: " + "X^1024 + 1");

# Quotient polynomial ring
R = PolynomialRing(GF(modulus), "X", implementation=use)
X = R.gen()
Y = R.quotient(X**_sage_const_1024  + _sage_const_1 , "x")
x = Y.gen()

# Shared matrix A
shared = generate_matrix(dimension, modulus)

# Alice and Bob secret matrices
#   TODO: make the matrix generation to come from Gaussian distribution
alice_secret = generate_matrix(dimension, modulus)
bob_secret = generate_matrix(dimension, modulus)

# Calculate the value B and B' for Alice and Bob respectively
alice_value = shared.transpose() * alice_secret
bob_value = bob_secret.transpose() * shared

# ** NO ERROR **

# Calculate Alice and Bob shared key. The result is: dimension X 1 matrix 
alice_key = (bob_value.transpose() * alice_secret.transpose())[_sage_const_0 , _sage_const_0 ]
bob_key = (bob_secret * alice_value.transpose()).transpose()[_sage_const_0 , _sage_const_0 ]

# Check if Alice's and Bob shared key match
print("shared key match before error: " + str(alice_key == bob_key)+ "\n")

# Calculate the shared key in Hex
alice_key_hex = str(hex(int(reconcile(alice_key, dimension, modulus), _sage_const_2 )))
bob_key_hex = str(hex(int(reconcile(bob_key, dimension, modulus), _sage_const_2 )))

# Print shared key
print("Alice's key in Hex: " + alice_key_hex + "\n")
print("Bob's key in Hex: " + bob_key_hex + "\n")
print("Alice's and Bob shared key match (no error): " + str(alice_key_hex == bob_key_hex))

# ** WITH ERROR **
# Generate Gaussian distribution for Alice and Bob
alice_dist = generate_distribution(dimension)
bob_dist = generate_distribution(dimension)

# Generate noise based on Gaussian distribution
alice_error = get_noise(dimension, modulus, alice_dist)
bob_error = get_noise(dimension, modulus, bob_dist)

# Print Alice and Bob error values
print ("Alice's error: \n" + str(alice_error) + "\n")
print ("Bob's error: \n" + str(bob_error)+ "\n")

# Add error to Alice's B and Bob's B' matrix
alice_value = alice_value + alice_error
bob_value = bob_value + bob_error

# Re-calculate the shared key for Alice and Bob
alice_key = (bob_value.transpose() * alice_secret.transpose())[_sage_const_0 , _sage_const_0 ]
bob_key = (bob_secret * alice_value.transpose()).transpose()[_sage_const_0 , _sage_const_0 ]

# Print Alice's and Bob's shared key which has error
print("Alice's key (with error): " + str(alice_key)+ "\n")
print("Bob's key (with error): " + str(bob_key)+ "\n")

# Calculate the shared key in Hex which has error
alice_key_hex = str(hex(int(reconcile(alice_key, dimension, modulus), _sage_const_2 )))
bob_key_hex = str(hex(int(reconcile(bob_key, dimension, modulus), _sage_const_2 )))

print("Shared polynomial match after error: " + str(alice_key == bob_key))

print("Alice's key in Hex: " + alice_key_hex)
print("Bob's key in Hex: " + bob_key_hex)
print("Alice's and Bob shared key match (with error) <method #1>: " + str(alice_key_hex == bob_key_hex))

alice_key_hex = str(hex(int(reconcile2(alice_key, dimension, modulus), _sage_const_2 )))
help = generate_signal(alice_key, dimension, modulus)
bob_key_hex = str(hex(int(reconcile2(bob_key, dimension, modulus, signal=help), _sage_const_2 )))

print("Alice's key in Hex: " + alice_key_hex)
print("Bob's key in Hex: " + bob_key_hex)
print("Alice's and Bob shared key match (with error using second rounding method) <method #2>: " + str(alice_key_hex == bob_key_hex))

print("=== %s seconds ===" % (time.time() - start_time))

